#ifndef OSMIUM_INDEX_MAP_HPP
#define OSMIUM_INDEX_MAP_HPP

/*

This file is part of Osmium (http://osmcode.org/osmium).

Copyright 2013 Jochen Topf <jochen@topf.org> and others (see README).

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/

#include <cstdint>

namespace osmium {

    /**
     * @brief Namespace for classes indexing OSM data.
     */
    namespace index {

        namespace map {

            /**
            * This abstract class defines an interface to storage classes
            * intended for storing small pieces of data (such as coordinates)
            * indexed by a positive object ID. The storage must be very
            * space efficient and able to scale to billions of objects.
            *
            * Subclasses have different implementations that will store the
            * data in different ways in memory and/or on disk. Some storage
            * classes are better suited when working with the whole planet,
            * some are better for data extracts.
            *
            * Note that these classes are not required to track "empty" fields.
            * When reading data you have to be sure you have put something in
            * there before.
            *
            * This storage class will only work on 64 bit systems if used for
            * storing node coordinates. 32 bit systems just can't address
            * that much memory!
            */
            template <typename TValue>
            class Map {

                Map(const Map&) = delete;
                Map& operator=(const Map&) = delete;

            public:

                Map() = default;
                virtual ~Map() = default;

                /// The "value" type, usually a coordinates class or similar.
                typedef TValue value_type;

                /// Set the field with id to value.
                virtual void set(const uint64_t id, const TValue value) = 0;

                /// Retrieve value by key. Does not check for overflow or empty fields.
                virtual const TValue operator[](const uint64_t id) const = 0;

                /**
                * Get the approximate number of items in the storage. The storage
                * might allocate memory in blocks, so this size might not be
                * accurate. You can not use this to find out how much memory the
                * storage uses. Use used_memory() for that.
                */
                virtual uint64_t size() const = 0;

                /**
                * Get the memory used for this storage in bytes. Note that this
                * is not necessarily entirely accurate but an approximation.
                * For storage classes that store the data in memory, this is
                * the main memory used, for storage classes storing data on disk
                * this is the memory used on disk.
                */
                virtual uint64_t used_memory() const = 0;

                /**
                * Clear memory used for this storage. After this you can not
                * use the storage container any more.
                */
                virtual void clear() = 0;

            }; // class Map

        } // namespace map

    } // namespace index

} // namespace osmium

#endif // OSMIUM_INDEX_MAP_HPP
