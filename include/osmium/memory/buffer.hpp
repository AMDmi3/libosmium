#ifndef OSMIUM_MEMORY_BUFFER_HPP
#define OSMIUM_MEMORY_BUFFER_HPP

/*

This file is part of Osmium (http://osmcode.org/osmium).

Copyright 2013 Jochen Topf <jochen@topf.org> and others (see README).

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/

#include <cassert>
#include <cstring>
#include <stdexcept>

#include <osmium/memory/item.hpp>
#include <osmium/memory/collection.hpp>

namespace osmium {

    /**
     * @brief Namespace for memory management.
     */
    namespace memory {

        /**
         * Exception thrown by the Buffer class when somebody tries to write data
         * into the buffer and it doesn't fit.
         */
        class BufferIsFull : public std::exception {};

        /**
         * A memory area for storing OSM and other objects. It is initialized
         * with a memory pointer, a size, and, optionally, the number of bytes
         * already committed to this buffer. OSM objects can't be just created
         * anywhere because they have varying sizes, they need this buffer to
         * live in.
         */
        class Buffer {

            char* m_data;
            size_t m_size;
            size_t m_written;
            size_t m_committed;

        public:

            Buffer() :
                m_data(nullptr),
                m_size(0),
                m_written(0),
                m_committed(0) {
            }

            Buffer(char* data, size_t size) :
                m_data(data),
                m_size(size),
                m_written(size),
                m_committed(size) {
                if (size % align_bytes != 0) {
                    throw std::invalid_argument("buffer size needs to be multiple of alignment");
                }
            }

            Buffer(char* data, size_t size, size_t committed) :
                m_data(data),
                m_size(size),
                m_written(committed),
                m_committed(committed) {
                if (size % align_bytes != 0) {
                    throw std::invalid_argument("buffer size needs to be multiple of alignment");
                }
                if (committed % align_bytes != 0) {
                    throw std::invalid_argument("buffer size needs to be multiple of alignment");
                }
            }

            Buffer(const Buffer&) = delete;
            Buffer& operator=(const Buffer&) = delete;

            Buffer(Buffer&&) = default;
            Buffer& operator=(Buffer&&) = default;

            ~Buffer() = default;

            char* data() const {
                return m_data;
            }

            size_t size() const {
                return m_size;
            }

            size_t committed() const {
                return m_committed;
            }

            /**
             * This tests if the current state of the buffer is aligned
             * properly. Only used for asserts.
             */
            bool is_aligned() const {
                return (m_written % align_bytes == 0) && (m_committed % align_bytes == 0);
            }

            size_t commit() {
                assert(is_aligned());
                size_t offset = m_committed;
                m_committed = m_written;
                return offset;
            }

            size_t clear() {
                size_t committed = m_committed;
                m_written = 0;
                m_committed = 0;
                return committed;
            }

            /**
             * Reserve space of given size in buffer and return pointer to it.
             */
            char* get_space(size_t size) {
                if (m_written + size > m_size) {
                    throw BufferIsFull();
                }
                char* data = &m_data[m_written];
                m_written += size;
                return data;
            }

            template <class T>
            T& get(const size_t offset) const {
                return *reinterpret_cast<T*>(&m_data[offset]);
            }

            /**
             * Add an item to the buffer. The size of the item is stored inside
             * the item, so we know how much memory to copy.
             */
            template <class T>
            T& add_item(const T& item) {
                char* ptr = get_space(item.padded_size());
                std::memcpy(ptr, &item, item.padded_size());
                return *reinterpret_cast<T*>(ptr);
            }

            /**
             * These iterators can be used to iterate over all items in
             * a buffer.
             */
            typedef osmium::memory::CollectionIterator<Item> iterator;
            typedef osmium::memory::CollectionIterator<const Item> const_iterator;

            iterator begin() {
                return iterator(m_data);
            }

            iterator end() {
                return iterator(m_data + m_committed);
            }

            const_iterator cbegin() const {
                return const_iterator(m_data);
            }

            const_iterator cend() const {
                return const_iterator(m_data + m_committed);
            }

            const_iterator begin() const {
                return cbegin();
            }

            const_iterator end() const {
                return cend();
            }

            operator bool() const {
                return m_data != nullptr;
            }

            friend void swap(Buffer& lhs, Buffer& rhs) {
                using std::swap;

                swap(lhs.m_data, rhs.m_data);
                swap(lhs.m_size, rhs.m_size);
                swap(lhs.m_written, rhs.m_written);
                swap(lhs.m_committed, rhs.m_committed);
            }

        }; // class Buffer

    } // namespace memory

} // namespace osmium

#endif // OSMIUM_MEMORY_BUFFER_HPP
